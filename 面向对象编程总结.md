
---
title: 面向对象编程总结
date: 2017-09-15 22:54:44
tags:
---
        ## composition(组合) has-a

在一个类中包含另外一个类


```
class Queue
{
    private:
        Dequeue c;
}

```

构建时，内部类先构建，外部类后构建，析构时，外部类先析构，内部类后析构。

编译器调用默认的构造函数完成内部类的构造。如果不希望使用默认构造函数的话，则需要自己在外部类的构造函数中，重新赋值。

如果外部类仅仅是对内部类的包装，修改了接口名，减少接口数目等，没有具体的实现，那么这种行为称作，adapater设计模式。

## delegation(委托)

在一个类中包含另外一个类的指针

```
class String
{
    private:
        StringRepr* rep;
}

```

### pimpl (pointer to implementation) has-a

使用委托时，可以只在外部类中设计接口，在内部类中完成接口的实现，外部类通过调用内部类的函数完成具体的功能。这种模式称为*pointer to implementation*。通常把接口类称为*handle*，把实现类称为*body*。
这种设计的好处，在于我们可以更改实现而不必修改接口。也不用重新编译接口类。


*String类和StringRepr类的pimpl设计，使得底层字符串相同的String可以共享同一片内存，即使用同一个StringRepr，只要在StringRepr中设计一个引用计数即可。我觉得这是大部分string不可以修改的原因，因为这种设计，修改意味着需要分配新内存并进行复制。*

## inheritance(继承) is-a

在数据成员方面，子类是完成包含父类的，在构造时，先完成父类的构造再完成子类的构造，析构时，先完成子类的析构，再完成父类的析构。

## 虚函数

继承从数据成员的角度来说，是父类的数据成员成为了子类的一部分。从成员函数的角度来说，是子类获得了父类函数的调用权。

对于任何一个成员函数，父类可以规定，子类不可以更改该函数的行为，子类可以更改该函数的行为，子类一定要定义该函数的行为。这三者分别对应，非虚函数，虚函数，纯虚函数
```
class Shape 
{
    public:
        virtual void draw() const = 0; // 纯虚函数
        virtual void error(const std::string& msg); // 虚函数
        int objectId() const; // 非虚函数
    
}
```

### 和虚函数有关的设计

#### Template Method

在父类中设计一个功能函数，这个功能函数在开头完成一些共同基本操作，然后调用一个需要特化的虚函数，然后再在结尾完成一些基本操作。

子类继承父类然后重载虚函数，然后再调用功能函数。

这种先将共同基本功能完成，然后由子类利用virtual function特性，完成具体功能的函数设计称为Template Method。

> MFC中OnFileOpen函数即采用这种设计，在这个函数中它首先完成文件名检查，文件打开等基本操作，然后调用Serial这个虚函数完成文件读取功能，然后再进行文件关闭等基本操作。子类继承父类后只需要重新定义Serial函数，然后再在子类对象上调用OnFileOpen，即可以完成文件的打开读取操作。

#### 使用 delegation + inheritance 设计观察者模式

基础：

委托即是在一个类中包含另外一个类的指针。
继承和虚函数一起使用具有多态特性。

场景：

假设一个这样的场景， 需要对一份数据可视化多个图表，数据变动时，每个图表都要进行变动，这种场景可以使用观察者模式来处理。

解决方案：

利用inheritance为图表类设计一个共同的基类，并设计一个负责更新图表的虚函数。

利用delegation设计一个数据类，在这个数据类中保存多个图表基类对象的指针。

当数据发生变动的时候，遍历图表基类指针，调用更新图表的虚函数即可。


#### 使用delegation + inheritance 

场景：

文件系统类，在文件系统中既有文件又有目录，目录可以包含文件也可以目录，如何设计类。

解决方案：

利用inheritance设计一个文件基类，然后从基类继承产生目录类和文件类，在目录类中可以利用delegation保存文件基类的指针。

#### 使用delegation + inheritance设计原型模式

场景：

假设有一个这样的框架，可以从框架中的基类派生类，然后调用父类的方法来构造派生类的对象。这里存在一个问题就是，基类如何知道派生类的名称，即使知道了派送类的名称如何构建派生类的实例。

解决方案：

利用delegation在基类中包括一个基类指针容器，然后在派生类中添加静态的派生类自己的对象，这个对象构造时将调用构造函数，在构造函数中将这个静态对象添加到基类的容器中。这样基类就可以访问派生类的对象，调用派生类的方法，如果派生类中有clone方法，即可以构造派生类对象。



