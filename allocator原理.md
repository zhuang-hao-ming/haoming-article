
---
title: allocator原理
date: 2017-09-15 22:54:44
tags:
---
        
`vc`,`borland c`, `gnu c`标准库所使用的默认内存分配器，只是简单地进行`malloc`和`free`而未进行内存管理。

`gnu c 2.9`中的`alloc`内存分配器设计了内存管理策略。

策略描述：

1. 分配器处理<=128bytes的小内存块，对于>128bytes的内存块，直接由`malloc`和`free`处理，不进行内存管理。
2. 对于小内存块，按照8bytes对齐，分为8,16,24,32,...,128bytes共16组,对于每组分别维护一个内存池(单链表)。
3. 对于容器发起的大小为N bytes（<=128bytes）的内存请求，分配器将N先调整到8的倍数，然后在对应的单链表中获取内存返回给用户。
4. 对于容器释放的大小为N bytes(<=128bytes)的内存，分配器将N先调整到8的倍数，然后将内存插回对应的单链表。
5. 如果在3中，单链表为空或者单链表已经耗尽，分配器将从`内存储备池（pool）`中获得大小为n(1=<n<=20) * size_of_block的内存（尽量多），然后将第一块内存返回给用户，剩余的内存插入对应的单链表中。
6. 在5中如果`内存储备池（pool）`的大小小于size_of_block，此时我们将这一小块内存称为碎片，应该将其插入到合适的链表中充分利用（`内存储备池（pool）`为空时不用处理碎片）。然后使用`malloc`申请内存，填充`内存储备池（pool）`。申请的大小为`size_of_block * 20 * 2 + roundup(已经申请过的内存>>4)`。根据这个公式我们知道分配器申请的内存，将越来越大，这是为了避免频繁的申请内存。
7. 如果为`内存储备池（pool）`申请内存失败，分配器将在比size_of_block大的链表中由近及远地查找是否有还未使用的内存块，如果有，取得一块将其加入`内存储备池（pool）`中，然后跳到步骤3。


问题：

1. alloc未有将内存还给操作系统的动作。