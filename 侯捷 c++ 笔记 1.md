
---
title: 侯捷 c++ 笔记 1
date: 2017-09-15 22:54:44
tags:
---
        
- 面向过程： 怎么写好一个函数
- 基于对象： 怎么写好一个类
- 面向对象： 怎么组合多个类



# 基于对象

设计类的时候主要分两种情况：

- 带指针的类
- 不带指针的类


## 不带指针的类

### 构造函数的写法：

1. 推荐使用*初始值列表*,使用*初始值列表*将在初始阶段完成数据成员的初始，比赋值的效率要高。
2. 可以设计私有的构造函数（单例模式）


### 成员函数

- 如果一个成员函数不会改变数据成员那么一定要加上const关键字（在小括号和大括号之间加）使它成为一个const函数。这样的设计可以抱住函数可以在const对象上被调用。

### 参数传递和返回值传递：

- 尽量使用pass by reference，pass by reference底层使用指针来实现，所以传递的数据大小和指针相同，效率高，而且语法比指针更加清晰。
- 如果不希望函数改变传递的实参，那么应该使用pass by reference （to const），如此，如果函数改变了实参，那么编译将不通过。
- 返回时也尽量使用return by reference, 但是，并不是所有的情况都可以使用return by reference，只有返回值所占用的内存已经存在了才可以return by reference，如果返回值所占用的内存是在函数中分配的那么只能return by value。
- 传递者并不需要考虑接受者究竟是以值还是引用的方式接受参数或者返回值。

### 友元

- 友元可以直接访问对象的私有数据成员。
- 类的函数可以访问类的所有对象的私有成员，友元函数也可以。


### 操作符重载

- 成员函数操作符重载, 左操作数是this，成员函数是左操作数的成员函数
- 非成员函数的操作符重载， 第一个参数是左操作数， 第二个参数是右操作数。适用范围更广。


### 匿名对象

- typename()


## 带指针的类


- 编写 BIG THREE

对于带指针的类，需要编写自己的*拷贝构造函数*，*拷贝赋值函数*，*析构函数*。原因是，编译器提供的这3个函数，*拷贝构造和赋值*完成的是一个字节一个字节的复制，而析构函数没有任何行为。在带有指针的类中，由于需要管理动态分配的内存，所以需要重新编写这3个函数。在*拷贝构造函数*中分配内存构造新对象。在*拷贝赋值函数*中释放已有的内存，然后重新分配内存，完成赋值。在*析构函数*中释放前面动态分配的内存。



### 内存策略

cpp在stack中存在3种不同类型的对象

- 局部对象， 生命周期和作用域在局部
- 局部静态对象， 作用域局部，生命周期全局
- 全局对象， 作用域和生命周期都是全局

#### 使用new和delete动态分配和回收内存的细节。

new的顺序：
1. 调用*operator new*函数分配内存(malloc)
2. 调用static_cast函数进行指针类型转换
3. 调用构造函数

delete的顺序：
1. 调用析构函数，销毁对象
2. 调用*operator delete*释放内存(free)

内存分配的细节：

动态申请分配的内存，除了数据占用的内存外还包括一些元数据占用的内存。在VC中，假设我们动态申请一个8字节的对象，那么我们实际使用的内存如下：

debug:

1. cookie 4字节
2. debug头 32字节
3. 数据 8字节
4. debug尾 4字节
5. pad 4字节
6. pad 4字节
7. pad 4字节
8. cookie 4字节

vc规定分配出去的内存一定要是16字节的倍数，如果不是，则使用4字节的pad补充。在cookie中记录了分配内存的大小，如上例，cookie的值为0X41, 4代表使用了64字节的内存，1代表内存还未释放，如果是0x40则代表内存已释放。

release:
1. cookie 4字节
2. 数据 8字节
3. cookie 4字节

在release模式下， 分配的内存大小恰好是16字节的倍数，所以不用使用pad来填补。cookie的值是0x11。

数组：

如果动态分配的对象是数组，那么会使用不同的内存结构，假设`new Complex[3]`，实际使用的内存结构如下：

debug:

1. cookie 4字节
2. debug header 32字节
3. length 4字节
4. data 8字节
5. data 8字节
6. data 8字节
7. debug tail 4字节
8. pad 4字节
9. pad 4字节
8. cookie 4字节

和非数组对象相比，数组对象多了4个字节用于保存动态分配的数组的长度。

relase：

1. cookie 4 bytes
2. length 4 bytes
3. data 8 bytes
4. data 8 bytes
5. data 8 bytes
6. pad 4 bytes
7. pad 4 bytes
8. pad 4 bytes
9. cookie 4 bytes

对于*array new*分配的内存要配套使用*array delete*来释放内存，虽然*delete*和*array delete*都可以正确的释放动态分配的内存，但是 *array delete*会根据length部分的值调用多次析构函数，保证对象分配的内存被正确释放。而*delete*只会调用一次析构函数。



## static

- static data member
- static member function
- static local variable

注意：
1. 静态的数据成员需要在类外定义：
```
double Account::rate = 1.0;

```
2. 静态的成员函数没有this参数，一般用来操作静态数据成员，静态成员函数既可以通过类调用也可以通过函数调用。
```

Accont::set_rate(2);
account.set_rate(2);

```
3. 静态局部变量

## cout
## 模板
## namespace